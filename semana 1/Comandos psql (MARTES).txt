

------------------------------------------------------- COMANDOS postgreSQL-----------------------------
\? = todos los comandos.
\l = bases de datos 
\c + nombre de la base de datos = conectame (a tal base de datos)
\dt = indica las relaciones encontradas. (las tablas dentro de tal database)
\d (nombre de tabla) = nos muestra el contenido de la tabla. (d === display)

\q = para salir.
ctrl +  



SNAKECASE En bases de datos se usa "snake_case".
NO ES CASE SENSITIVE. Por buena practica todos los comandos en mayusc.
en sql se debe usar ;
Si aparece postgres-# <-- Signifca que esta esperando a que termines la instruccion.


DATE = fecha (DOB)
INTEGER = number en bases de datos.
VARCHAR =  es el tipo de dato mas comun en sql (string)
BOOL = true/false

(              Comando Create table , nombre de la tabla, nombre de columna mas tipo de dato -> mas coma, cuando se finaliza ";"
Cracion tablas: tasks_db=# CREATE TABLE users (username varchar, email varchar, password varchar);

----------------------------------------------------- INFO EN TABLA --------------------------

INSERT INTO

indicamos el comando + nombre de tabla + (valores, que se van, a, alterar)
tasks_db=# INSERT INTO users (username, email, password) 
Inmediatamente abajo ("indicamos con comillas simples", la info por campo");
tasks_db-# VALUES ('Brandon', 'brandon@gmail.com', '1234');


MOSTRAR INFO AÑADIDA A LA TABLA.
   
Comando SELECT el * = all // de users;

--> tasks_db=# SELECT * FROM users;

Timestamps en psql (aaaa-MM-dd HH:mm:ss)


 INSERT INTO posts (title, descripction, user_id, category_id,createdAt)VALUES ('Dudas con Sequelize', 'ALguien podría darme una mano con como poner un valor por defecto en unmodelo', 1, 3, '2023-03-01 20:42:31');
INSERT INTO posts (title, descripction, user_id, category_id) VALUES ('Dudas con Sequelize', 'ALguien podría darme una mano con como poner un valor por defecto en unmodelo', 1, 3);
============================================================= EJERCICIO 1 EN psql

======================================== Crear una base de datos.

--CREATE DATABASE mi_primer_db;
crear  (que vas a crear) --> nombre de lo creado  (Siempre cerrar con ; <-- Sino dara errores).

-- DROP DATABASE mi_primer_db;  <-- ELIMNAR BD.




-- \l  <-- Revisar bases de datos.
--\dt <-- todas las tablas.
--\c  <-- conctame a la tabla ...
--\q  <-- salir de la tabla 
--\d   <-- Para conocer las columnas, tablas de una base de datos.


==================================================== CREANDO TABLA Y AGREGANDO DATOS.=================

postgres=# CREATE DATABASE cars;
CREATE DATABASE


CREATE TABLE "car_model" (
  "id" INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  "model" varchar(25) UNIQUE NOT NULL,
  "brand" varchar(25) NOT NULL
);fg

                                                    
postgres=# \c cars
Ahora está conectado a la base de datos «cars» con el usuario «postgres».

cars=# CREATE TABLE cars (nombre varchar(30), correo varchar(30), modelo varchar(20), año int);
CREATE TABLE
cars=# \dt

        Listado de relaciones
 Esquema | Nombre | Tipo  |  Due±o
---------+--------+-------+----------
 public  | cars   | tabla | postgres
(1 fila)


cars=# \d cars

                          Tabla ½public.cars╗
 Columna |         Tipo          | Ordenamiento | Nulable | Por omisi≤n
---------+-----------------------+--------------+---------+-------------
 nombre  | character varying(30) |              |         |
 correo  | character varying(30) |              |         |
 modelo  | character varying(20) |              |         |
 año     | integer               |              |         |



cars=# INSERT INTO cars (nombre, correo, modelo, año) VALUES ('Brandon', 'brandon@academlo.com','swift', 2021);
INSERT 0 1    <---- CORROBORA QUE SE AGREGO EXITOSAMENTE.


cars=# SELECT * from cars;  <--- PARA CONSULTAR LA INFO AGREGADA
 nombre  |        correo        | modelo | año
---------+----------------------+--------+------
 Brandon | brandon@academlo.com | swift  | 2021
(1 fila)

                                                            ^
cars=# INSERT INTO cars (nombre,correo,modelo, año) VALUES ('Rafael', 'rafael@gmail.com', 'vw', 2020), ('Pedro', 'pedro@academlo.com', 'nissan', 2020);
INSERT 0 2 <-- se ingresaron dos filas.

                                         ^
cars=# INSERT INTO cars VALUES ('vero', 'vero@academlo', 'renualt', 2022);
INSERT 0 1   <-- Se ingreso una fila.


cars=# select * from cars;
 nombre  |        correo        | modelo  | año
---------+----------------------+---------+------
 Brandon | brandon@academlo.com | swift   | 2021
 Rafael  | rafael@gmail.com     | vw      | 2020
 Pedro   | pedro@academlo.com   | nissan  | 2020
 vero    | vero@academlo        | renualt | 2022
(4 filas)


CONDICIONES DE BUSQUEDA.

cars=# SELECT * FROM cars WHERE nombre='Brandon'; <-- donde el usuario de llama brandon
 nombre  |        correo        | modelo | año
---------+----------------------+--------+------
 Brandon | brandon@academlo.com | swift  | 2021
(1 fila)



ELIMINAR FILA(ROW).

DELETE FROM categories WHERE id=1;


ELIMINAR COLUMNA(COLUMN)

ALTER TABLE categories DROP COLUMN name;



============================================================================ INFO IMPORTANTE DE NOTION.

## Restricciones (Constraints)

Las restricciones pueden ser agregadas a las columnas y pueden ser usadas para agregar información acerca de los datos que serán almacenados en las columnas y como será su comportamiento. 

Esto se hace al momento de crear una nueva tabla. Las restricciones son agregadas a las columnas **después de especificar el tipo de dato**. Una restricción hará que nuestra base de datos rechace los datos que no cumplan lo indicado por las restricciones.

1. **PRIMARY KEY (PK)**
    
    Indica que una determinada columna será usada para identificar una fila, esto a su vez asegura que cada valor de dicha columna sea único. 
    
2. **FOREIGN KEY (FK)**
    
    Es usado para prevenir acciones que pueden destruir la conexión entre tablas. Es un campo o colección de campos en una tabla que hacen referencia a la llave primaría **PK** de otra tabla.
    
3. **NOT NULL**
    
    Garantizará que se guardará un valor para una columna, en pocas palabras esto nos ayuda a que no falten datos/valores en el registro de una tabla.
    
4. **UNIQUE**
    
    Garantiza que cada valor de una columna sea único.
    
5. **DEFAULT**
    
    Establece un valor para ser el valor por defecto en caso de que no se proporcione el valor para una columna.
    

## Palabras clave

1. **AS** permite que columnas o tablas sean renombradas usando un alias.
2. **DISTINCT** filtra todos los valores duplicados en una columna y regresa valores únicos cuando extraemos información desde una tabla.
3. **WHERE** como lo vimos anteriormente es una herramienta poderosa que nos permite filtrar información para que solo veamos datos que cumplan con el criterio. Los operadores de comparación pueden ser usados cuando usamos esta clausula. 
4. **LIKE** puede ser usado para comparar valores similares. 
5. **IS NULL y IS NOT NULL** puede ser usado para extraer registros donde hace falta datos o donde no hace falta datos.
6. **BETWEEN** es usado con la clausula WHERE para filtrar datos con un cierto rango. Acepta dos valores y pueden ser números, texto o fechas.
7. **AND** permite que múltiples criterios sean agregados a una consulta.
8. **OR** al igual que **AND** permite agregar múltiples criterios, sin embargo regresará aquellos registros que cumplan cualquiera de los criterios. 
9. **ORDER BY** ordena los resultados que regresa una consulta. Por defecto los registros serán ordenados de forma ascendente (alfabéticamente o numéricamente). El resultado puede ser invertido usando la palabra clave **DESC**.
10. **LIMIT** permite limitar la cantidad de resultados obtenidos por la consulta.








**Ver los comandos disponibles para postgres**

```bash
 \?
```

**Listas todas las bases de datos**

```bash
\l
```

**Cambiar a otra BD**

```bash
\c nombre_BD
```

**Ver las tablas en una base de datos**

```bash
\dt --> data tables
```

**Describir una tabla**

```bash
\d nombre_tabla
```

**Ver todos los comandos SQL**

```bash
\h
```

**Ver como se ejecuta un comando SQL**

```bash
\h nombre_de_la_funcion
```

**Quitar toda la descripción en la terminal**

```bash
Ctrl + C
```

**Ver la versión de Postgres, es importante poner al final ';'**

```bash
SELECT version();
```

**Volver a ejecutar la función realizada anteriormente**

```bash
\g
```

**Iniciar el contador de tiempo para que la consola te diga en cada ejecución cuanto fue el tiempo en ejecutar esa función**

```bash
\timing
```

**Limpiar la consola**

```bash
Ctrl + L
```